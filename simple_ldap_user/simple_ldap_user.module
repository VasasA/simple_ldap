<?php
/**
 * @file
 * Main simple_ldap_user module file.
 */

/**
 * Implements hook_menu().
 */
function simple_ldap_user_menu() {
  $items = array();

  $items['admin/config/people/simple_ldap/user'] = array(
    'title' => 'Users',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('simple_ldap_user_admin'),
    'access arguments' => array('administer site configuration'),
    'file' => 'simple_ldap_user.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Overrides the built-in user module's list of users, setting accounts to
 * "blocked" if there is no matching LDAP account.
 */
function simple_ldap_user_form_user_admin_account_alter(&$form, &$form_state, $form_id) {
  // Update the user array.
  foreach ($form['accounts']['#options'] as $uid => $user) {

    // Don't mess with user/1.
    if ($uid == 1) {
      continue;
    }

    // Verify active users. Blocked users may be provisioned to LDAP when they
    // are set to active, so they are left alone here.
    if ($user['status'] == 'active') {
      // Load the Drupal user object.
      $drupal_user = user_load($uid);

      // Check whether the user exists in LDAP.
      $ldap_user = SimpleLdapUser::singleton($drupal_user->name);
      if (!$ldap_user->exists) {
        $form['accounts']['#options'][$uid]['status'] = 'blocked';
      }
    }
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * Specifies that SimpleLdapuserController should be used to load users instead
 * of the default controller.
 */
function simple_ldap_user_entity_info_alter(&$entity_info) {
  if (isset($entity_info['user'])) {
    // Use the SimpleLdapUserController class to manage users.
    $entity_info['user']['controller class'] = 'SimpleLdapUserController';
  }
}

/**
 * Implements hook_form_alter().
 */
function simple_ldap_user_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'user_login_block':
      // Remove the register and password reminder links.
      $server = SimpleLdapServer::singleton();
      if ($server->readonly) {
        unset($form['links']);
      }
    case 'user_login':
      array_unshift($form['#validate'], 'simple_ldap_user_login_name_validate');
      break;

    case 'user_profile_form':
      // Disable mapped fields if LDAP Server is read-only.
      $server = SimpleLdapServer::singleton();
      if ($server->readonly) {
        $attribute_map = simple_ldap_user_map();

        // Mail and Password are special attributes.
        $form['account']['mail']['#disabled'] = $server->readonly;
        $form['account']['pass']['#disabled'] = $server->readonly;

        // Other mapped fields.
        foreach ($attribute_map as $attribute) {
          switch ($attribute['type']) {
            case 'field':
              $form[$attribute['drupal']]['#disabled'] = $server->readonly;
              break;

            case 'default':
            default:
              $form['account'][$attribute['drupal']]['#disabled'] = $server->readonly;
          }
        }

      }
      break;

    default:
  }
}

/**
 * Implements hook_menu_alter().
 *
 * Disables the user register and password reminder pages if the LDAP server is
 * read-only.
 */
function simple_ldap_user_menu_alter(&$items) {
  $server = SimpleLdapServer::singleton();
  if ($server->readonly) {
    unset($items['user/register']);
    unset($items['user/password']);
  }
}

/**
 * Implements hook_user_login().
 *
 * Fires when a user logs in.
 *
 * @param array $edit
 *   The form values submitted by the user to log in,
 *   including raw username and password.
 */
function simple_ldap_user_user_login(&$edit, $account) {
  $sync = variable_get('simple_ldap_user_sync');
  if ($sync == 'hook_user_login') {
    switch (simple_ldap_user_source()) {
      case 'ldap':
        simple_ldap_user_sync_to_drupal($account);
        break;

      case 'drupal':
        simple_ldap_user_sync_to_ldap($account);
        break;
    }
  }
}

/**
 * Implements hook_user_logout().
 *
 * Fires when the user logs out.
 *
 * @todo simple_ldap_user_user_logout()
 */
function simple_ldap_user_user_logout($account) {
}

/**
 * Implements hook_user_presave().
 *
 * Fires before an account is created or changed.
 *
 * @param array $edit
 *   The form values submitted by the user.
 */
function simple_ldap_user_user_presave(&$edit, $account, $category) {
  if ($account->is_new && isset($edit['name'])) {
    $ldap_user = SimpleLdapUser::singleton($edit['name']);

    if ($ldap_user->exists) {
      // Force an initial sync from LDAP to drupal.
      $attribute_mail = variable_get('simple_ldap_user_attribute_mail');
      $attribute_map = simple_ldap_user_map();

      // Get the user's email address.
      $edit['mail'] = $ldap_user->{$attribute_mail}[0];

      // Get the remaining mapped attributes.
      foreach ($attribute_map as $attribute) {
        switch ($attribute['type']) {
          // Use Field API.
          case 'field':
            for ($i = 0; $i < $ldap_user->{$attribute['ldap']}['count']; $i++) {
              $edit[$attribute['drupal']][LANGUAGE_NONE][$i]['value'] = $ldap_user->{$attribute['ldap']}[$i];
            }
            break;

          // Use the user object directly.
          case 'default':
          default:
            $edit[$attribute['drupal']] = $ldap_user->{$attribute['ldap']}[0];
        }
      }
    }
  }
}

/**
 * Implements hook_user_insert().
 *
 * Fires after a new account is created.
 *
 * @param array $edit
 *   The form values submitted by the user.
 */
function simple_ldap_user_user_insert(&$edit, $account, $category) {
  $ldap_user = SimpleLdapUser::singleton($account->name);
  if (!$ldap_user->exists) {
    module_invoke_all('sync_to_ldap', $account);
  }
}

/**
 * Implements hook_user_update().
 *
 * Fires when a user account is edited.
 *
 * @param array $edit
 *   The form values submitted by the user.
 */
function simple_ldap_user_user_update(&$edit, $account, $category) {
  $ldap_user = SimpleLdapUser::singleton($account->name);
  if ((isset($edit['status']) && $edit['status']) || $ldap_user->exists) {
    module_invoke_all('sync_to_ldap', $account);
  }
}

/**
 * Implements hook_user_cancel().
 *
 * Fires on user account cancellations, before account is
 * cancelled. Operates on all cancellations except delete.
 *
 * @param array $edit
 *   The form values submitted by the user.
 * @param string $method
 *   The type of cancellation,
 *   see http://lb.cm/user_cancel_methods-7
 *
 * @todo simple_ldap_user_user_cancel()
 */
function simple_ldap_user_user_cancel($edit, $account, $method) {
}

/**
 * Implements hook_user_delete().
 *
 * Fires when a user account is deleted, before account is
 * deleted.
 */
function simple_ldap_user_user_delete($account) {
  $ldap_user = SimpleLdapUser::singleton($account->name);
  $ldap_user->delete();
}

/**
 * Implements hook_user_load().
 *
 * Fires when user information is being loaded from the database.
 * User information is cached, so this does not fire every time
 * a user object is handled.
 */
function simple_ldap_user_user_load($users) {
  $sync = variable_get('simple_ldap_user_sync');
  if ($sync == 'hook_user_load') {
    foreach ($users as $user) {
      switch (simple_ldap_user_source()) {
        case 'ldap':
          simple_ldap_user_sync_to_drupal($user);
          break;

        case 'drupal':
          simple_ldap_user_sync_to_ldap($user);
          break;
      }
    }
  }
}

/**
 * Implements hook_user_view().
 *
 * Fires when user account information is being viewed.
 *
 * @todo simple_ldap_user_user_view()
 */
function simple_ldap_user_user_view($account, $view_mode, $langcode) {
}

/**
 * Validate the username on a login form.
 */
function simple_ldap_user_login_name_validate($form, &$form_state) {
  // Get the username from the form data.
  $name = trim($form_state['values']['name']);

  // Load the LDAP user with the given username.
  $ldap_user = SimpleLdapUser::singleton($name);

  // If the user exists in LDAP, make sure a matching Drupal account exists.
  if ($ldap_user->exists) {
    $drupal_user = user_load_by_name($name);
    if (empty($drupal_user)) {
      $attribute_name = variable_get('simple_ldap_user_attribute_name');
      $account = array(
        'name' => $ldap_user->{$attribute_name}[0],
        'status' => 1,
      );
      $drupal_user = user_save(NULL, $account);
    }
  }
}

/**
 * Returns whether simple_ldap_user has been configured.
 *
 * @todo - Is this used?
 */
function simple_ldap_user_configured() {
  $configured = TRUE;

  // Check each of the required configuration items.
  $configured = $configured && variable_get('simple_ldap_user_basedn') !== NULL;
  $configured = $configured && variable_get('simple_ldap_user_scope') !== NULL;
  $configured = $configured && variable_get('simple_ldap_user_objectclass') !== NULL;
  $configured = $configured && variable_get('simple_ldap_user_attribute_name') !== NULL;
  $configured = $configured && variable_get('simple_ldap_user_attribute_mail') !== NULL;

  return $configured;
}

/**
 * Returns the configured data sync direction.
 *
 * The sync direction is dependent on both the configurations of simple_ldap and
 * simple_ldap_user.
 */
function simple_ldap_user_source() {
  $server = SimpleLdapServer::singleton();

  // If the LDAP server is set to read-only, force ldap->drupal sync.
  if ($server->readonly) {
    return 'ldap';
  }

  // Get the sync config from simple_ldap_user, defaulting to ldap->drupal.
  return variable_get('simple_ldap_user_source', 'ldap');
}

/**
 * Returns the attribute map, if configured.
 */
function simple_ldap_user_map() {
  $map = variable_get('simple_ldap_user_map', array());
  foreach ($map as $key => $value) {
    // LDAP likes lowercase.
    $map[$key]['ldap'] = strtolower($map[$key]['ldap']);

    // Make sure a type is set.
    if (!isset($value['type'])) {
      $map[$key]['type'] = 'default';
    }

    // Make sure "required" is set.
    if (!isset($value['required'])) {
      $map[$key]['required'] = FALSE;
    }
  }
  return $map;
}

/**
 * Synchronizes Drupal user properties to LDAP.
 */
function simple_ldap_user_sync_to_ldap($drupal_user) {
  // simple_ldap_user configuration.
  $attribute_name = variable_get('simple_ldap_user_attribute_name');
  $attribute_mail = variable_get('simple_ldap_user_attribute_mail');
  $attribute_pass = variable_get('simple_ldap_user_attribute_pass');
  $attribute_map = simple_ldap_user_map();

  // Load the LDAP user.
  $ldap_user = SimpleLdapUser::singleton($drupal_user->name);

  // Mail is a special attribute.
  $ldap_user->$attribute_mail = $drupal_user->mail;

  // Password is a special attribute.
  $ldap_user->$attribute_pass = $drupal_user->pass;

  // Synchronize the fields in the attribute map.
  foreach ($attribute_map as $attribute) {
    switch ($attribute['type']) {

      // Get the value using Field API.
      case 'field':
        // Get drupal field values.
        $items = field_get_items('user', $drupal_user, $attribute['drupal']);
        $values = array();
        if (is_array($items)) {
          foreach ($items as $item) {
            $values[] = $item['value'];
          }
        }

        // Synchronize.
        $ldap_user->{$attribute['ldap']} = $values;
        break;

      // Get the value directly from the user object.
      case 'default':
      default:
        $ldap_user->{$attribute['ldap']} = $drupal_user->{$attribute['drupal']};
    }
  }

  // Save any changes.
  $result = $ldap_user->save();
  return $result;
}

/**
 * Synchronizes LDAP attributes to Drupal user properties.
 */
function simple_ldap_user_sync_to_drupal($drupal_user) {
  // simple_ldap_user configuration.
  $attribute_name = variable_get('simple_ldap_user_attribute_name');
  $attribute_mail = variable_get('simple_ldap_user_attribute_mail');
  $attribute_map = simple_ldap_user_map();

  // Load the LDAP user.
  $ldap_user = SimpleLdapUser::singleton($drupal_user->name);

  // Nothing to sync.
  if (!$ldap_user->exists || (isset($drupal_user->uid) && $drupal_user->uid == 1)) {
    return;
  }

  // Initialize array of attribute changes.
  $edit = array();

  // Mail is a special attribute.
  if ($drupal_user->mail != $ldap_user->{$attribute_mail}[0]) {
    $edit['mail'] = $ldap_user->{$attribute_mail}[0];
  }

  // Synchronize the fields in the attribute map.
  foreach ($attribute_map as $attribute) {
    if (isset($drupal_user->{$attribute['drupal']})) {
      switch ($attribute['type']) {

        // Update the value in drupal using Field API.
        case 'field':
          // Get the Drupal field values and metadata.
          $items = field_get_items('user', $drupal_user, $attribute['drupal']);
          $info = field_info_field($attribute['drupal']);
          $language = field_language('user', $drupal_user, $attribute['drupal']);

          // Synchronize.
          $dirty = FALSE;
          for ($i = 0; $i < $ldap_user->{$attribute['ldap']}['count']; $i++) {
            if ($i < $info['cardinality'] || $info['cardinality'] == FIELD_CARDINALITY_UNLIMITED) {
              $edit[$attribute['drupal']][$language][$i]['value'] = $ldap_user->{$attribute['ldap']}[$i];
              if ($items[$i]['value'] != $ldap_user->{$attribute['ldap']}[$i]) {
                $dirty = TRUE;
              }
            }
          }

          // Check if any changes were actually made.
          if (!$dirty) {
            unset($edit[$attribute['drupal']]);
          }
          break;

        // Update the value directly on the user object.
        case 'default':
        default:
          if (isset($ldap_user->{$attribute['ldap']}[0]) && $drupal_user->{$attribute['drupal']} != $ldap_user->{$attribute['ldap']}[0]) {
            $edit[$attribute['drupal']] = $ldap_user->{$attribute['ldap']}[0];
          }
      }
    }
  }

  // Save any changes.
  if (!empty($edit)) {
    if (!isset($drupal_user->original)) {
      // This avoids an infinite load/save loop.
      $drupal_user->original = clone $drupal_user;
    }
    $drupal_user = user_save($drupal_user, $edit);
  }

  // Synchronized user.
  return $drupal_user;
}

/**
 * Returns an array of supported hash types.
 */
function simple_ldap_user_hash_types() {
  $types = array();

  // Crypt, and Salted Crypt.
  $types['crypt'] = t('Crypt');
  $types['salted crypt'] = t('Salted Crypt');

  // Extended DES.
  if (defined('CRYPT_EXT_DES') || CRYPT_EXT_DES == 1) {
    $types['extended des'] = t('Extended DES');
  }

  // MD5Crypt.
  if (defined('CRYPT_MD5') || CRYPT_MD5 == 1) {
    $types['md5crypt'] = t('MD5Crypt');
  }

  // Blowfish.
  if (defined('CRYPT_BLOWFISH') || CRYPT_BLOWFISH == 1) {
    $types['blowfish'] = t('Blowfish');
  }

  // MD5
  $types['md5'] = t('MD5');

  // SMD5.
  if (function_exists('mhash') && function_exists('mhash_keygen_s2k')) {
    $types['salted md5'] = t('Salted MD5');
  }

  // SHA.
  $types['sha'] = t('SHA');

  // SSHA.
  if (function_exists('mhash') && function_exists('mhash_keygen_s2k')) {
    $types['salted sha'] = t('Salted SHA');
  }

  return $types;
}

/**
 * Generate a random salt of the given length.
 */
function simple_ldap_user_random_salt($length) {
  $possible = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ./';
  $str = '';

  mt_srand((double) microtime() * 1000000);
  while (strlen($str) < $length) {
    $str .= substr($possible, (rand() % strlen($possible)), 1);
  }

  return $str;
}

/**
 * Hash a string for use in an LDAP password field.
 */
function simple_ldap_user_hash($string, $algorithm = NULL) {
  if ($algorithm === NULL) {
    $algorithm = variable_get('simple_ldap_user_password_hash');
  }

  switch ($algorithm) {
    case 'crypt':
      $hash = '{CRYPT}' . crypt($string, substr($string, 0, 2));
      break;

    case 'salted crypt':
      $hash = '{CRYPT}' . crypt($string, simple_ldap_user_random_salt(2));
      break;

    case 'extended des':
      $hash = '{CRYPT}' . crypt($string, '_' . simple_ldap_user_random_salt(8));
      break;

    case 'md5crypt':
      $hash = '{CRYPT}' . crypt($string, '$1$' . simple_ldap_user_random_salt(9));
      break;

    case 'blowfish':
      $hash = '{CRYPT}' . crypt($string, '$2a$12$' . simple_ldap_user_random_salt(13));
      break;

    case 'md5':
      $hash = '{MD5}' . base64_encode(pack('H*', md5($string)));
      break;

    case 'salted md5':
      mt_srand((double) microtime() * 1000000);
      $salt = mhash_keygen_s2k(MHASH_MD5, $string, substr(pack('h*', md5(mt_rand())), 0, 8), 4);
      $hash = '{SMD5}' . base64_encode(mhash(MHASH_MD5, $string . $salt) . $salt);
      break;

    case 'sha':
      $hash = '{SHA}' . base64_encode(pack('H*', sha1($string)));
      break;

    case 'salted sha':
      mt_srand((double) microtime() * 1000000);
      $salt = mhash_keygen_s2k(MHASH_SHA1, $string, substr(pack('h*', md5(mt_rand())), 0, 8), 4);
      $hash = '{SSHA}' . base64_encode(mhash(MHASH_SHA1, $string . $salt) . $salt);
      break;

    case 'none':
    default:
      $hash = $string;
  }

  return $hash;
}
